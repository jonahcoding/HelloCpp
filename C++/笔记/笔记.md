# C++内存管理

## 一、C++内存分区

## 1.1 内存划分

C++内存划分为五个区：**栈、堆、自由存储区、全局/静态存储区、常量存储区**。

**栈区**：存放局部变量、函数形参和返回值，函数结束即释放。效率高但内存有限。

**堆区**：由程序员使用malloc()等函数申请，使用free()释放。

**自由存储区**：通过new申请的内存，对应使用delete释放。未释放的内存，程序结束后由OS回收。

**全局/静态存储区**：存放全局变量和静态变量，申请的内存在程序全部结束后释放。

**常量存储区**：存放程序运行期间不能被改变的常量，如：10，字符串常量"abc"，数组名等。

*问题：为什么栈比堆得效率高？*

> 申请速度：栈，编译时分配。堆，运行时动态分配（动态分配速度取决于分配算法和机器运行速度）。
>
> 存储寻址：栈，物理地址连续。堆，物理地址不一定连续，查找堆得链表耗费时间，故寻址速度慢。
>
> CPU操作：栈，计算机有特定的寄存器（esp、ebp）操作栈。堆：使用间接寻址。

### 1.2 堆区与自由存储区的区别（重点）

> C++标准未做明确区分，但多数（几乎所有）编译器的new/delete以malloc/free为基础来实现。

**总结：**

1. 自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。
2. 堆是C语言和OS的术语，是OS维护的一块特殊内存。
3. new申请的内存区域在C++中称为自由存储区，由堆实现，可说new申请的内存在堆上。
4. 堆与自由存储区非等价关系（可重载new改用其它方式实现自由存储区）

### 1.3 堆区与栈区的区别

①管理方式

> 堆：程序员手动管理。
>
> 栈：编译器自动管理。

②空间大小

>堆：接近于内存（虚拟内存）的总大小。
>
>栈：Windows系统1M，Linux系统8M或10M。

③碎片问题

> 堆：频繁malloc/free造成内存空间不连续，产生碎片，影响效率。
>
> 栈：先进后出，不会产生碎片。

④分配方式

> 堆：动态分配。
>
> 栈：静态分配（由编译器完成，如局部变量）+动态分配（alloca函数，编译器释放，不同于堆）

⑤分配效率

> 堆：由C/C++库函数提供，机制复杂，效率低。
>
> 栈：数据结构由机器系统提供，计算机底层提供支持，效率极高。

## 二、malloc、free

### 2.1 malloc()

**函数原型：**

```c++
void * malloc(unsigned int size); 
```

- 分配的内存大小为size参数指定的字节数。
- 不对分配的内存进行初始化，内存中可以是任意值。

- 返回值：
  - 成功：返回一个万能指针（可转为任意类型），指向申请的内存的起始地址。
  - 失败：返回NULL。

**使用示例：**
```c++
//为字符串shinrin申请内存
char * pName;
pName = (char*)malloc(strlen("shinrin") + 1);//	+1：系统自动追加结束符'\0'
if(pName != NULL)
{ 
    strcpy(pName, "shinrin"); 
}
free(pName);

//为Person类申请内存（Person为自定义类型）
Person* person = (Person*)malloc(sizeof(Person));
if(person !== NULL)
{
    free(person);
}
```

### 2.2 扩展

**calloc()函数原型：**

```c++
void * calloc(unsigned int n,unsigned int size);
```

- 函数说明：申请n个大小为size的内存空间。
- 函数特点：对申请的内存进行初始化，初始值为0。
- 返回值：
  - 成功：返回一个存放指针的数组，数组元素指向申请的内存的起始地址。
  - 失败：返回NULL。

**realloc()函数原型：**

```c++
void * realloc(void *p,unsigned int size);
```

- 函数说明：将指针p所指向的已分配内存区的大小改为size。
- 参数要求：size必须大于原有内存大小。
- 函数详解：
  - 如果原有内存后的连续空间充足，只进行扩展即可。
  - 否则，申请新的内存空间，拷贝原有数据并释放旧内存。
- 返回值：
  - 成功：返回一个指针，指向新内存的起始地址。
  - 失败：返回NULL。

### 2.3 malloc()的缺点

1. 程序员必须确定对象的长度。
2. malloc()返回void *，C++不允许将void *赋值给其它类型的指针，必须使用强转。
3. malloc()可能申请内存失败，需要依据返回值进行判断。
4. **malloc()只为对象分配内存，不调用对象的构造方法（初始化）。**

##  三、new、delete

**new 表达式= 申请内存空间（new操作符） + 引发构造函数**

**new 表达式 != new操作符**

### 3.1 new的使用

**自定义类型Person：**

```c++
class Person
{
public:
	int m_Age;

	Person()
	{
		cout << "new无参构造函数（默认构造函数）" << endl;
	}

	Person(int age)
	{
		cout << "new有参构造" << endl;
		m_Age = age;
	}

	~Person()
	{
		cout << "new析构函数" << endl;
	}
};
```

**在栈上为数组分配空间：**

```c++
//Person数组
Person pArray[10] = { Person(10), Person(20), Person(30) };
//3个有参构造创建的Person对象，7个无参构造创建的Person对象。
```

**使用new为自定义类型分配内存：**

```c++
//Person为自定义类型
//申请内存，调用构造函数
Person *p = new Person;
//调用析构函数，释放内存
delete p;
```

**使用new为数组分配内存**

```c++
//int数组
int *pInt = new int[10];

//Person数组
Person *p = new Person[10];//【重点：堆区开辟数组，将调用默认构造函数（确保默认构造函数存在）】
//10个无参构造创建的Person对象。
delete[] p;// 【重点：释放数组使用delete[] p，而非delete p】
```

### 3.2 new与malloc()的区别（重点）

①属性

> new是C++关键字，需要编译器支持。
>
> malloc()是C库函数，需要头文件支持。

②参数

> 使用new操作符申请内存时无需指定内存块大小，编译器将按照类型信息自行计算。
>
> 使用malloc()需要显式指出要申请的内存大小。

③返回类型

> new内存分配成功后，返回对象类型的指针，类型严格与对象匹配，无需进行类型转换。
>
> malloc内存分配成功返回void*，需要强制类型转换成需要的类型。

④分配失败

> new内存分配失败，抛出bac_alloc异常。
>
> malloc分配内存失败返回NULL。

⑤自定义类型

> new先调用operator new函数，申请空间（底层malloc()实现），然后调用类的构造函数初始化成员变量，最后返回自定义类型指针。delete先调用类的析构函数，然后调用operator delete函数释放内存（底层free()实现）。
>
> malloc/free是库函数，只能动态的申请和释放内存，无法处理自定义类型的构造与析构。

⑥重载

> new/delete操作符可以重载，如：*布局new* 使用指定的已有内存空间，不再重新申请。
>
> malloc()不能重载。

⑦内存区域

> new操作符从自由存储区上为对象动态分配内存，凡通过new申请获得的内存均为自由存储区。
>
> C语言使用malloc()从堆上分配内存。

*注：布局new是new操作符的一种变体（重载），可指定要使用的内存。*

### 3.3 new/delete的重载

**全局重载**

```c++
void * operator new(size_t size){
    void *p = malloc(size);
    return (p);
}

void operator delete(void *p);{
    free(p);
}
```

**对单个类重载的new/delete重载**

```c++
class TestClass {
    public:
        void * operator new(size_t size);
        void operator delete(void *p);
};
void *TestClass::operator new(size_t size)
{
    void *p = malloc(size); // Replace this with alternative allocator
    return (p);
}
void TestClass::operator delete(void *p)
{
    free(p);
}
```

**new[]和delete[]的重载**

```c++
class TestClass{
    public:
        void *operator new[](size_t size);
        void operator delete[](void *p);
}

void *TestClass::operator new[](size_t size){
    void *p=malloc(size);
    return p;
}

void TestClass:operator delete[](void *p){
    free(p);
}

int main(){
    TestClass *p=new TestClass[10];
    delete[] p;
}
```

## 四、注意事项

- 动态内存的申请与释放相匹配，避免内存泄漏。
- 使用free或delete释放内存后，将指针置为NULL，防止产生野指针。

------

***未完，待续。***
