**本节内容**

- [x] C++内存划分
- [x] 自由存储区与堆的区分
- [x] 堆区与栈区的区别
- [x] new与malloc的区别

# 一、C++内存分区

## 1.1 内存划分

**内存划分**：

C++内存从高地址到低地址依次划分为： 栈、堆、全局/静态存储区、常量存储区、代码区。 

|      分区       | 概述                                                         |
| :-------------: | ------------------------------------------------------------ |
|      栈区       | 存放局部变量、函数形参和返回值，函数结束即释放。效率高但内存有限。 |
|      堆区       | 由程序员使用malloc()等函数申请，使用free()释放。             |
| 全局/静态存储区 | 存放全局变量和静态变量，申请的内存在程序全部结束后释放。     |
|   常量存储区    | 存放程序运行期间不能被改变的常量，如：10，字符串常量"abc"，数组名等。 |
|     代码区      | 存放函数体的二进制代码。                                     |

**代码示例：**

```cpp
#include <iostream>

int a = 0;                      //全局/静态存储区（初始化区）
char* p1;                       //全局/静态存储区（未初始化区）

int main()
{
    int b;                      // b：栈区 
    char s[] = "abc ";          // s：栈区，"abc "：常量区 
    char* p2;                   //p2：栈区 
    const char* p3 = "123456 "; //p3：栈区，
    static int c = 0;           // c：全局（静态）初始化区 
    p1 = (char*)malloc(10);     //p1：栈区，分配的空间：堆区
    p2 = (char*)malloc(20);     //p2：栈区，分配的空间：堆区
    strcpy(p1, "123456 ");      //"123456 "：常量区
    //编译器可能会将"123456 "与p3所指向的"123456 "优化成一个地方。 
    
    return 0;
}
```

注：VS2019中使用```const char* p3 = "123456 ";```替换```char* p3 = "123456 ";```，详细见[这里](https://blog.csdn.net/weixin_44690935/article/details/108502989)。

**思考**：

*问题一：为什么栈比堆的效率高？*

|          | 堆                                             | 栈                                 |
| -------- | ---------------------------------------------- | ---------------------------------- |
| 申请内存 | 运行时动态分配（取决于分配算法和机器运行速度） | 编译时分配                         |
| 存储寻址 | 物理地址未必连续，查找堆的链表耗时，寻址速度慢 | 物理地址连续，结构简单             |
| CPU操作  | 函数库提供支持，间接寻址                       | 计算机底层支持，特定的寄存器操作栈 |

*问题二：为什么不放弃堆更多得使用栈？*

1. 栈先进后出，不灵活。

2. 待补充。

## 1.2 全局/静态存储区

在*C语言*下，全局/静态存储区划分为初始化区（data段）和未初始化区（bss段）。

|    分区    | 概述                                                         |
| :--------: | ------------------------------------------------------------ |
|  初始化区  | 存放*初始化值非0*的全局变量和静态变量。                      |
| 未初始化区 | 存放*初始化值为0以及未初始化*（默认初始值为0）的全局变量和静态变量。 |

划分原理：已初始化区保存初始值。未初始化区只记录字节数，加载到内存时全部置0。

划分目的：减小目标文件或节省目标文件所占的磁盘空间。

## 1.3 自由存储区

**自由存储区的定义**：

1. 通过new申请的内存属于自由存储区，对应使用delete释放。
2. 未释放的内存，程序结束后由OS回收。
3. 多数（几乎所有）编译器的new/delete以malloc/free为基础来实现。

**自由存储区与堆的区分**：

1. 自由存储是C++中通过new和delete动态分配和释放对象的抽象概念。
2. 堆是C语言和OS的术语，是OS维护的一块特殊内存。
3. new申请的内存区域在C++中称为自由存储区，由堆实现，可以说new申请的内存在堆上。
4. 堆与自由存储区非等价关系（可重载new改用其它方式实现自由存储区）

## 1.4 堆区与栈区的区别

|          | 堆                                 | 栈                                                           |
| -------- | ---------------------------------- | ------------------------------------------------------------ |
| 管理方式 | 程序员手动管理                     | 编译器自动管理                                               |
| 空间大小 | Windows32位4G                      | Windows32位系统1M，Linux系统8M或10M                          |
| 生长方式 | 向上生长（低地址==>高地址）        | 向下生长（高地址==>低地址）                                  |
| 碎片问题 | 频繁申请释放，空间不连续，产生碎片 | 先进后出，不会产生碎片                                       |
| 分配方式 | 动态分配（程序运行时）             | 静态分配（程序编译时）+动态分配（[alloca函数](https://baike.baidu.com/item/alloca/7621487?fr=aladdin)） |
| 分配效率 | C/C++库函数提供，机制复杂，效率低  | 计算机底层提供支持，效率高                                   |

**注**：栈的动态分配的内存由系统回收。

# 二、malloc与new

## 2.1 malloc

**malloc函数原型：**

```cpp
void * malloc(unsigned int size); 
```

> 函数说明：分配大小为size参数指定的字节数的内存。
>
> 函数特点：不对分配的内存进行初始化，内存中可以是任意值。
>
> 返回值：
>
> - 成功：返回一个万能指针（可转为任意类型），指向申请的内存的起始地址。
>
> - 失败：返回NULL。

**使用示例：**
```cpp
//为字符串hello world申请内存
char * pName;
pName = (char*)malloc(strlen("hello world") + 1);//	+1：系统自动追加结束符'\0'
if(pName != NULL)
{ 
    strcpy(pName, "hello world"); 
}
free(pName);

//为Person类申请内存（Person为自定义类型）
Person* person = (Person*)malloc(sizeof(Person));
if(person !== NULL)
{
    free(person);
}
```

**malloc()的缺点：**

1. 程序员必须确定对象的长度。
2. malloc()返回void *，C++不允许将void *赋值给其它类型的指针，必须使用强转。
3. malloc()可能申请内存失败，需要依据返回值进行判断。
4. malloc()只为对象分配内存，不调用对象的构造方法（初始化）。

## 2.2 malloc扩展

**calloc()函数原型：**

```cpp
void * calloc(unsigned int n,unsigned int size);
```

> 函数说明：申请n个大小为size的内存空间。
>
> 函数特点：对申请的内存进行初始化，初始值为0。
>
> 返回值：
>
> - 成功：返回一个存放指针的数组，数组元素指向申请的内存的起始地址。
>
> - 失败：返回NULL。

**realloc()函数原型：**

```cpp
void * realloc(void *p,unsigned int size);
```

> 函数说明：将指针p所指向的已分配内存区的大小改为size。
>
> 参数要求：size必须大于原有内存大小。
>
> 函数详解：若原内存后的连续空间充足，只进行扩展。否则，申请新内存空间，拷贝原数据并释放旧内存。
>
> 返回值：
>
> - 成功：返回一个指针，指向新内存的起始地址。
>
> - 失败：返回NULL。

## 2.3 new

C++关键字：申请内存，引发自定义类型的构造函数。

**自定义类型Person：**

```cpp
class Person
{
public:
	int m_Age;

	Person()
	{
		cout << "new无参构造函数（默认构造函数）" << endl;
	}

	Person(int age)
	{
		cout << "new有参构造" << endl;
		m_Age = age;
	}

	~Person()
	{
		cout << "new析构函数" << endl;
	}
};
```

**在栈上为数组分配空间：**

```cpp
//Person数组
Person pArray[10] = { Person(10), Person(20), Person(30) };
//3个有参构造创建的Person对象，7个无参构造创建的Person对象。
```

**使用new为自定义类型分配内存：**

```cpp
//Person为自定义类型
//申请内存，调用构造函数
Person *p = new Person;
//调用析构函数，释放内存
delete p;
```

**使用new为数组分配内存**

```cpp
//int数组
int *pInt = new int[10];

//Person数组
Person *p = new Person[10];//【重点：堆区开辟数组，将调用默认构造函数（确保默认构造函数存在）】
//10个无参构造创建的Person对象。
delete[] p;// 【重点：释放数组使用delete[] p，而非delete p】
```

## 2.3 new重载

**全局重载**：

```cpp
void * operator new(size_t size){
    void *p = malloc(size);
    return (p);
}

void operator delete(void *p);{
    free(p);
}
```

**对单个类重载的new/delete重载**：

```cpp
class TestClass {
    public:
        void * operator new(size_t size)
        {
            void *p = malloc(size); 
    		return (p);
        }
        void operator delete(void *p)
        {
            free(p);
        }
};
```

**new[]和delete[]的重载**：

```cpp
class TestClass{
    public:
        void *operator new[](size_t size)
        {
            void *p=malloc(size);
    		return p;
        }
        void operator delete[](void *p)
        {
            free(p);
        }
}

int main(){
    TestClass *p=new TestClass[10];
    delete[] p;
    
    return 0;
}
```

## 2.5 new与malloc()的区别

|            | new                                         | malloc()                         |
| ---------- | ------------------------------------------- | -------------------------------- |
| 属性       | C++关键字，需要编译器支持                   | C库函数，需要头文件支持          |
| 参数       | 无需指定，编译器按类型信息自行计算          | 显式指出要申请的内存大小（字节） |
| 返回类型   | 返回对象类型的指针                          | 返回void*，需要强制转换          |
| 分配失败   | 抛出bac_alloc异常                           | 返回NULL                         |
| 自定义类型 | 申请内存空间，调用构造，返回自定义类型指针  | 只申请内存空间，不调用构造       |
| 重载       | 可重载                                      | 不能重载                         |
| 内存区域   | 自由存储区（默认实现在堆上，可重载new改变） | 堆                               |

*注1：布局new是new操作符的一种变体（重载），可指定要使用的内存。*

*关于delete：调用自定义类型的析构函数，再释放内存空间。*

# 三、其它

- 动态内存的申请与释放相匹配，避免内存泄漏。
- 使用free或delete释放内存后，将指针置为NULL，防止产生野指针。

------

***未完，待续。***

