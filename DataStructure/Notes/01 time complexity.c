/*
==================================================
时间复杂度：
    默认执行一行指令花费一个unit_time
简化：
	大O标记法中，可以省略掉系数、低阶、常量（n趋于无穷）。
	
--------------------------------------------------
伪代码（一）：
	int sum = 0;    //  unit_time
	int i;    //  unit_time
	for (i = 0; i < n; i++) //  n * unit_time
	{
		sum += i;   //  n * unit_time
	}
	return sum; //  忽略不计
	
以上代码执行花费的时间为：T(n) = (2n+2) * unit_time
令f(n) = 2n+2
T(n)：算法执行的总时间。
f(n)：算法执行的总次数。
T(n) = O(f(n))
时间复杂度为：O(2n+2) = O(n)

--------------------------------------------------
 伪代码（二）：
	 int sum = 0;    //  unit_time
	 int i = 0;    //  unit_time
	 int j = 0;    //  unit_time
	 for(i; i < n; i++)   //  n * unit_time
	 {
		j = 0;   //  n * unit_time
		for(; j < n; j++)   //  n * n * unit_time
		{
			sum += i;   //  n * n * unit_time
		}
	 }
	 return sum;

 3 * unit_time + 2n * unit_time + 2n^2 * unit_time
 时间复杂度为：O(3+2n+2n^2) = O(n^2)
 
--------------------------------------------------
 常见时间复杂度：
    O(1)：数组取值
    O(logn)：二分查找、二叉查找树的增删改查
    O(n)：链表的查找
    O(nlogn)：快速排序、堆排序
    O(n^2)：冒泡排序、插入排序
    O(2^n)：递归（斐波那契数列）f(n) = f(n - 1) + f(n - 2)
    O(n!)：排列（阶乘）
	
--------------------------------------------------
最好（最快）、最坏（最慢）、平均时间复杂度：

bool find_element(int a[], int x)
{
	int pos = -1;
	int i = 0;
	for(i; i < length; i++)
	{
		if(a[i] == x)
		{
			pos = i;
			break;
		}
	}
	return pos;
}

时间复杂度：O(n)
最好时间复杂度：O(1)（第一次即找到）
最坏时间复杂度：O(n)（第n次找到或未找到）
平均时间复杂度：

要查找变量x在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。
	
平均时间复杂度：(1+2+3+...n + n)/(n+1) = (n + n(n-1)/2 + n) / (n+1)
				= (3n + n^2) / 2 = (n(n+3)) / (2(n+1)) = O(n)
				
加权平均时间复杂度：
	1、在数组中的概率为1/2，每一种发生的概率为1/(2n)
	2、不在数组中的概率为1/2，仅此一种概率为n/2
	考虑每种情况发生的概率（乘法法则，加权平均值，期望值）：
		1/(2n) + 2/(2n) + ... + n/(2n) + n/2
		= 3(n+1) / 4) = O(n)
		
均摊时间复杂度：
	摊还分析法：
==================================================
*/